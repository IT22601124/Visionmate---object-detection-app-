{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  getPermissionsAsync: true,\n  requestPermissionsAsync: true,\n  usePermissions: true,\n  Recording: true,\n  PermissionStatus: true\n};\nObject.defineProperty(exports, \"PermissionStatus\", {\n  enumerable: true,\n  get: function get() {\n    return _expoModulesCore.PermissionStatus;\n  }\n});\nexports.Recording = void 0;\nexports.getPermissionsAsync = getPermissionsAsync;\nexports.requestPermissionsAsync = requestPermissionsAsync;\nexports.usePermissions = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\nvar _expoModulesCore = require(\"expo-modules-core\");\nvar _AudioAvailability = require(\"./AudioAvailability\");\nvar _RecordingConstants = require(\"./RecordingConstants\");\nObject.keys(_RecordingConstants).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _RecordingConstants[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _RecordingConstants[key];\n    }\n  });\n});\nvar _Sound = require(\"./Sound\");\nvar _AV = require(\"../AV\");\nvar _ExponentAV = _interopRequireDefault(require(\"../ExponentAV\"));\nvar _Recording2 = require(\"./Recording.types\");\nObject.keys(_Recording2).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _Recording2[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Recording2[key];\n    }\n  });\n});\nvar _Recording;\nvar _recorderExists = false;\nvar eventEmitter = _expoModulesCore.Platform.OS === 'android' ? new _expoModulesCore.EventEmitter(_ExponentAV.default) : null;\nfunction getPermissionsAsync() {\n  return _getPermissionsAsync.apply(this, arguments);\n}\nfunction _getPermissionsAsync() {\n  _getPermissionsAsync = (0, _asyncToGenerator2.default)(function* () {\n    return _ExponentAV.default.getPermissionsAsync();\n  });\n  return _getPermissionsAsync.apply(this, arguments);\n}\nfunction requestPermissionsAsync() {\n  return _requestPermissionsAsync.apply(this, arguments);\n}\nfunction _requestPermissionsAsync() {\n  _requestPermissionsAsync = (0, _asyncToGenerator2.default)(function* () {\n    return _ExponentAV.default.requestPermissionsAsync();\n  });\n  return _requestPermissionsAsync.apply(this, arguments);\n}\nvar usePermissions = exports.usePermissions = (0, _expoModulesCore.createPermissionHook)({\n  getMethod: getPermissionsAsync,\n  requestMethod: requestPermissionsAsync\n});\nvar Recording = exports.Recording = function () {\n  function Recording() {\n    var _this = this;\n    (0, _classCallCheck2.default)(this, Recording);\n    this._subscription = null;\n    this._canRecord = false;\n    this._isDoneRecording = false;\n    this._finalDurationMillis = 0;\n    this._uri = null;\n    this._onRecordingStatusUpdate = null;\n    this._progressUpdateTimeoutVariable = null;\n    this._progressUpdateIntervalMillis = _AV._DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n    this._options = null;\n    this._cleanupForUnloadedRecorder = function () {\n      var _ref = (0, _asyncToGenerator2.default)(function* (finalStatus) {\n        var _finalStatus$duration;\n        _this._canRecord = false;\n        _this._isDoneRecording = true;\n        _this._finalDurationMillis = (_finalStatus$duration = finalStatus == null ? void 0 : finalStatus.durationMillis) != null ? _finalStatus$duration : 0;\n        _recorderExists = false;\n        if (_this._subscription) {\n          _this._subscription.remove();\n          _this._subscription = null;\n        }\n        _this._disablePolling();\n        return yield _this.getStatusAsync();\n      });\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    this._pollingLoop = (0, _asyncToGenerator2.default)(function* () {\n      if ((0, _AudioAvailability.isAudioEnabled)() && _this._canRecord && _this._onRecordingStatusUpdate != null) {\n        _this._progressUpdateTimeoutVariable = setTimeout(_this._pollingLoop, _this._progressUpdateIntervalMillis);\n        try {\n          yield _this.getStatusAsync();\n        } catch (_unused) {\n          _this._disablePolling();\n        }\n      }\n    });\n    this.getStatusAsync = (0, _asyncToGenerator2.default)(function* () {\n      if (_this._canRecord) {\n        return _this._performOperationAndHandleStatusAsync(function () {\n          return _ExponentAV.default.getAudioRecordingStatus();\n        });\n      }\n      var status = {\n        canRecord: false,\n        isRecording: false,\n        isDoneRecording: _this._isDoneRecording,\n        durationMillis: _this._finalDurationMillis\n      };\n      _this._callOnRecordingStatusUpdateForNewStatus(status);\n      return status;\n    });\n  }\n  return (0, _createClass2.default)(Recording, [{\n    key: \"_disablePolling\",\n    value: function _disablePolling() {\n      if (this._progressUpdateTimeoutVariable != null) {\n        clearTimeout(this._progressUpdateTimeoutVariable);\n        this._progressUpdateTimeoutVariable = null;\n      }\n    }\n  }, {\n    key: \"_enablePollingIfNecessaryAndPossible\",\n    value: function _enablePollingIfNecessaryAndPossible() {\n      if ((0, _AudioAvailability.isAudioEnabled)() && this._canRecord && this._onRecordingStatusUpdate != null) {\n        this._disablePolling();\n        this._pollingLoop();\n      }\n    }\n  }, {\n    key: \"_callOnRecordingStatusUpdateForNewStatus\",\n    value: function _callOnRecordingStatusUpdateForNewStatus(status) {\n      if (this._onRecordingStatusUpdate != null) {\n        this._onRecordingStatusUpdate(status);\n      }\n    }\n  }, {\n    key: \"_performOperationAndHandleStatusAsync\",\n    value: function () {\n      var _performOperationAndHandleStatusAsync2 = (0, _asyncToGenerator2.default)(function* (operation) {\n        (0, _AudioAvailability.throwIfAudioIsDisabled)();\n        if (this._canRecord) {\n          var status = yield operation();\n          this._callOnRecordingStatusUpdateForNewStatus(status);\n          return status;\n        } else {\n          throw new Error('Cannot complete operation because this recorder is not ready to record.');\n        }\n      });\n      function _performOperationAndHandleStatusAsync(_x2) {\n        return _performOperationAndHandleStatusAsync2.apply(this, arguments);\n      }\n      return _performOperationAndHandleStatusAsync;\n    }()\n  }, {\n    key: \"setOnRecordingStatusUpdate\",\n    value: function setOnRecordingStatusUpdate(onRecordingStatusUpdate) {\n      this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n      if (onRecordingStatusUpdate == null) {\n        this._disablePolling();\n      } else {\n        this._enablePollingIfNecessaryAndPossible();\n      }\n      this.getStatusAsync();\n    }\n  }, {\n    key: \"setProgressUpdateInterval\",\n    value: function setProgressUpdateInterval(progressUpdateIntervalMillis) {\n      this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n      this.getStatusAsync();\n    }\n  }, {\n    key: \"prepareToRecordAsync\",\n    value: function () {\n      var _prepareToRecordAsync = (0, _asyncToGenerator2.default)(function* () {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _RecordingConstants.RecordingOptionsPresets.LOW_QUALITY;\n        (0, _AudioAvailability.throwIfAudioIsDisabled)();\n        if (_recorderExists) {\n          throw new Error('Only one Recording object can be prepared at a given time.');\n        }\n        if (this._isDoneRecording) {\n          throw new Error('This Recording object is done recording; you must make a new one.');\n        }\n        if (!options || !options.android || !options.ios) {\n          throw new Error('You must provide recording options for android and ios in order to prepare to record.');\n        }\n        var extensionRegex = /^\\.\\w+$/;\n        if (!options.android.extension || !options.ios.extension || !extensionRegex.test(options.android.extension) || !extensionRegex.test(options.ios.extension)) {\n          throw new Error(`Your file extensions must match ${extensionRegex.toString()}.`);\n        }\n        if (!this._canRecord) {\n          if (eventEmitter) {\n            this._subscription = eventEmitter.addListener('Expo.Recording.recorderUnloaded', this._cleanupForUnloadedRecorder);\n          }\n          var _yield$ExponentAV$pre = yield _ExponentAV.default.prepareAudioRecorder(options),\n            uri = _yield$ExponentAV$pre.uri,\n            status = _yield$ExponentAV$pre.status;\n          _recorderExists = true;\n          this._uri = uri;\n          this._options = options;\n          this._canRecord = true;\n          var currentStatus = Object.assign({}, status, {\n            canRecord: true\n          });\n          this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n          this._enablePollingIfNecessaryAndPossible();\n          return currentStatus;\n        } else {\n          throw new Error('This Recording object is already prepared to record.');\n        }\n      });\n      function prepareToRecordAsync() {\n        return _prepareToRecordAsync.apply(this, arguments);\n      }\n      return prepareToRecordAsync;\n    }()\n  }, {\n    key: \"getAvailableInputs\",\n    value: (function () {\n      var _getAvailableInputs = (0, _asyncToGenerator2.default)(function* () {\n        return _ExponentAV.default.getAvailableInputs();\n      });\n      function getAvailableInputs() {\n        return _getAvailableInputs.apply(this, arguments);\n      }\n      return getAvailableInputs;\n    }())\n  }, {\n    key: \"getCurrentInput\",\n    value: (function () {\n      var _getCurrentInput = (0, _asyncToGenerator2.default)(function* () {\n        return _ExponentAV.default.getCurrentInput();\n      });\n      function getCurrentInput() {\n        return _getCurrentInput.apply(this, arguments);\n      }\n      return getCurrentInput;\n    }())\n  }, {\n    key: \"setInput\",\n    value: (function () {\n      var _setInput = (0, _asyncToGenerator2.default)(function* (inputUid) {\n        return _ExponentAV.default.setInput(inputUid);\n      });\n      function setInput(_x3) {\n        return _setInput.apply(this, arguments);\n      }\n      return setInput;\n    }())\n  }, {\n    key: \"startAsync\",\n    value: (function () {\n      var _startAsync = (0, _asyncToGenerator2.default)(function* () {\n        return this._performOperationAndHandleStatusAsync(function () {\n          return _ExponentAV.default.startAudioRecording();\n        });\n      });\n      function startAsync() {\n        return _startAsync.apply(this, arguments);\n      }\n      return startAsync;\n    }())\n  }, {\n    key: \"pauseAsync\",\n    value: (function () {\n      var _pauseAsync = (0, _asyncToGenerator2.default)(function* () {\n        return this._performOperationAndHandleStatusAsync(function () {\n          return _ExponentAV.default.pauseAudioRecording();\n        });\n      });\n      function pauseAsync() {\n        return _pauseAsync.apply(this, arguments);\n      }\n      return pauseAsync;\n    }())\n  }, {\n    key: \"stopAndUnloadAsync\",\n    value: (function () {\n      var _stopAndUnloadAsync = (0, _asyncToGenerator2.default)(function* () {\n        var _stopResult;\n        if (!this._canRecord) {\n          if (this._isDoneRecording) {\n            throw new Error('Cannot unload a Recording that has already been unloaded.');\n          } else {\n            throw new Error('Cannot unload a Recording that has not been prepared.');\n          }\n        }\n        var stopResult;\n        var stopError;\n        try {\n          stopResult = yield _ExponentAV.default.stopAudioRecording();\n        } catch (err) {\n          stopError = err;\n        }\n        if (_expoModulesCore.Platform.OS === 'web' && ((_stopResult = stopResult) == null ? void 0 : _stopResult.uri) !== undefined) {\n          this._uri = stopResult.uri;\n        }\n        yield _ExponentAV.default.unloadAudioRecorder();\n        var status = yield this._cleanupForUnloadedRecorder(stopResult);\n        return stopError ? Promise.reject(stopError) : status;\n      });\n      function stopAndUnloadAsync() {\n        return _stopAndUnloadAsync.apply(this, arguments);\n      }\n      return stopAndUnloadAsync;\n    }())\n  }, {\n    key: \"getURI\",\n    value: function getURI() {\n      return this._uri;\n    }\n  }, {\n    key: \"createNewLoadedSound\",\n    value: (function () {\n      var _createNewLoadedSound = (0, _asyncToGenerator2.default)(function* () {\n        var initialStatus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var onPlaybackStatusUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        console.warn(`createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name`);\n        return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n      });\n      function createNewLoadedSound() {\n        return _createNewLoadedSound.apply(this, arguments);\n      }\n      return createNewLoadedSound;\n    }())\n  }, {\n    key: \"createNewLoadedSoundAsync\",\n    value: (function () {\n      var _createNewLoadedSoundAsync = (0, _asyncToGenerator2.default)(function* () {\n        var initialStatus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var onPlaybackStatusUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        if (this._uri == null || !this._isDoneRecording) {\n          throw new Error('Cannot create sound when the Recording has not finished!');\n        }\n        return _Sound.Sound.createAsync({\n          uri: this._uri\n        }, initialStatus, onPlaybackStatusUpdate, false);\n      });\n      function createNewLoadedSoundAsync() {\n        return _createNewLoadedSoundAsync.apply(this, arguments);\n      }\n      return createNewLoadedSoundAsync;\n    }())\n  }]);\n}();\n_Recording = Recording;\nRecording.createAsync = (0, _asyncToGenerator2.default)(function* () {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _RecordingConstants.RecordingOptionsPresets.LOW_QUALITY;\n  var onRecordingStatusUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var progressUpdateIntervalMillis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var recording = new _Recording();\n  if (progressUpdateIntervalMillis) {\n    recording._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n  }\n  recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n  yield recording.prepareToRecordAsync(Object.assign({}, options, {\n    keepAudioActiveHint: true\n  }));\n  try {\n    var status = yield recording.startAsync();\n    return {\n      recording: recording,\n      status: status\n    };\n  } catch (err) {\n    recording.stopAndUnloadAsync();\n    throw err;\n  }\n});","map":{"version":3,"names":["_expoModulesCore","require","_AudioAvailability","_RecordingConstants","Object","keys","forEach","key","prototype","hasOwnProperty","call","_exportNames","exports","defineProperty","enumerable","get","_Sound","_AV","_ExponentAV","_interopRequireDefault","_Recording2","_Recording","_recorderExists","eventEmitter","Platform","OS","EventEmitter","ExponentAV","getPermissionsAsync","_getPermissionsAsync","apply","arguments","_asyncToGenerator2","default","requestPermissionsAsync","_requestPermissionsAsync","usePermissions","createPermissionHook","getMethod","requestMethod","Recording","_this","_classCallCheck2","_subscription","_canRecord","_isDoneRecording","_finalDurationMillis","_uri","_onRecordingStatusUpdate","_progressUpdateTimeoutVariable","_progressUpdateIntervalMillis","_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS","_options","_cleanupForUnloadedRecorder","_ref","finalStatus","_finalStatus$duration","durationMillis","remove","_disablePolling","getStatusAsync","_x","_pollingLoop","isAudioEnabled","setTimeout","_unused","_performOperationAndHandleStatusAsync","getAudioRecordingStatus","status","canRecord","isRecording","isDoneRecording","_callOnRecordingStatusUpdateForNewStatus","_createClass2","value","clearTimeout","_enablePollingIfNecessaryAndPossible","_performOperationAndHandleStatusAsync2","operation","throwIfAudioIsDisabled","Error","_x2","setOnRecordingStatusUpdate","onRecordingStatusUpdate","setProgressUpdateInterval","progressUpdateIntervalMillis","_prepareToRecordAsync","options","length","undefined","RecordingOptionsPresets","LOW_QUALITY","android","ios","extensionRegex","extension","test","toString","addListener","_yield$ExponentAV$pre","prepareAudioRecorder","uri","currentStatus","assign","prepareToRecordAsync","_getAvailableInputs","getAvailableInputs","_getCurrentInput","getCurrentInput","_setInput","inputUid","setInput","_x3","_startAsync","startAudioRecording","startAsync","_pauseAsync","pauseAudioRecording","pauseAsync","_stopAndUnloadAsync","_stopResult","stopResult","stopError","stopAudioRecording","err","unloadAudioRecorder","Promise","reject","stopAndUnloadAsync","getURI","_createNewLoadedSound","initialStatus","onPlaybackStatusUpdate","console","warn","createNewLoadedSoundAsync","createNewLoadedSound","_createNewLoadedSoundAsync","Sound","createAsync","recording","keepAudioActiveHint"],"sources":["F:\\node\\vision\\node_modules\\expo-av\\src\\Audio\\Recording.ts"],"sourcesContent":["import {\n  PermissionResponse,\n  PermissionStatus,\n  PermissionHookOptions,\n  createPermissionHook,\n  EventEmitter,\n  Subscription,\n  Platform,\n} from 'expo-modules-core';\n\nimport { isAudioEnabled, throwIfAudioIsDisabled } from './AudioAvailability';\nimport {\n  RecordingInput,\n  RecordingObject,\n  RecordingOptions,\n  RecordingStatus,\n} from './Recording.types';\nimport { RecordingOptionsPresets } from './RecordingConstants';\nimport { Sound, SoundObject } from './Sound';\nimport {\n  _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n} from '../AV';\nimport ExponentAV from '../ExponentAV';\n\nlet _recorderExists: boolean = false;\nconst eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\n\n/**\n * Checks user's permissions for audio recording.\n * @return A promise that resolves to an object of type `PermissionResponse`.\n * @platform android\n * @platform ios\n */\nexport async function getPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.getPermissionsAsync();\n}\n\n/**\n * Asks the user to grant permissions for audio recording.\n * @return A promise that resolves to an object of type `PermissionResponse`.\n * @platform android\n * @platform ios\n */\nexport async function requestPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.requestPermissionsAsync();\n}\n\n/**\n * Check or request permissions to record audio.\n * This uses both `requestPermissionAsync` and `getPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [permissionResponse, requestPermission] = Audio.usePermissions();\n * ```\n */\nexport const usePermissions = createPermissionHook({\n  getMethod: getPermissionsAsync,\n  requestMethod: requestPermissionsAsync,\n});\n\n// @needsAudit\n/**\n * > **warning** **Warning**: Experimental for web.\n *\n * This class represents an audio recording. After creating an instance of this class, `prepareToRecordAsync`\n * must be called in order to record audio. Once recording is finished, call `stopAndUnloadAsync`. Note that\n * only one recorder is allowed to exist in the state between `prepareToRecordAsync` and `stopAndUnloadAsync`\n * at any given time.\n *\n * Note that your experience must request audio recording permissions in order for recording to function.\n * See the [`Permissions` module](/guides/permissions) for more details.\n *\n * Additionally, audio recording is [not supported in the iOS Simulator](/workflow/ios-simulator/#limitations).\n *\n * @example\n * ```ts\n * const recording = new Audio.Recording();\n * try {\n *   await recording.prepareToRecordAsync(Audio.RecordingOptionsPresets.HIGH_QUALITY);\n *   await recording.startAsync();\n *   // You are now recording!\n * } catch (error) {\n *   // An error occurred!\n * }\n * ```\n *\n * @return A newly constructed instance of `Audio.Recording`.\n * @platform android\n * @platform ios\n */\nexport class Recording {\n  _subscription: Subscription | null = null;\n  _canRecord: boolean = false;\n  _isDoneRecording: boolean = false;\n  _finalDurationMillis: number = 0;\n  _uri: string | null = null;\n  _onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null;\n  _progressUpdateTimeoutVariable: number | null = null;\n  _progressUpdateIntervalMillis: number = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n  _options: RecordingOptions | null = null;\n\n  // Internal methods\n\n  _cleanupForUnloadedRecorder = async (finalStatus?: RecordingStatus) => {\n    this._canRecord = false;\n    this._isDoneRecording = true;\n    this._finalDurationMillis = finalStatus?.durationMillis ?? 0;\n    _recorderExists = false;\n    if (this._subscription) {\n      this._subscription.remove();\n      this._subscription = null;\n    }\n    this._disablePolling();\n    return await this.getStatusAsync(); // Automatically calls onRecordingStatusUpdate for the final state.\n  };\n\n  _pollingLoop = async () => {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._progressUpdateTimeoutVariable = setTimeout(\n        this._pollingLoop,\n        this._progressUpdateIntervalMillis\n      ) as any;\n      try {\n        await this.getStatusAsync();\n      } catch {\n        this._disablePolling();\n      }\n    }\n  };\n\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n\n  _enablePollingIfNecessaryAndPossible() {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._disablePolling();\n      this._pollingLoop();\n    }\n  }\n\n  _callOnRecordingStatusUpdateForNewStatus(status: RecordingStatus) {\n    if (this._onRecordingStatusUpdate != null) {\n      this._onRecordingStatusUpdate(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<RecordingStatus>\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n    if (this._canRecord) {\n      const status = await operation();\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because this recorder is not ready to record.');\n    }\n  }\n\n  /**\n   * Creates and starts a recording using the given options, with optional `onRecordingStatusUpdate` and `progressUpdateIntervalMillis`.\n   *\n   * ```ts\n   * const { recording, status } = await Audio.Recording.createAsync(\n   *   options,\n   *   onRecordingStatusUpdate,\n   *   progressUpdateIntervalMillis\n   * );\n   *\n   * // Which is equivalent to the following:\n   * const recording = new Audio.Recording();\n   * await recording.prepareToRecordAsync(options);\n   * recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n   * await recording.startAsync();\n   * ```\n   *\n   * @param options Options for the recording, including sample rate, bitrate, channels, format, encoder, and extension. If no options are passed to,\n   * the recorder will be created with options `Audio.RecordingOptionsPresets.LOW_QUALITY`. See below for details on `RecordingOptions`.\n   * @param onRecordingStatusUpdate A function taking a single parameter `status` (a dictionary, described in `getStatusAsync`).\n   * @param progressUpdateIntervalMillis The interval between calls of `onRecordingStatusUpdate`. This value defaults to 500 milliseconds.\n   *\n   * @example\n   * ```ts\n   * try {\n   *   const { recording: recordingObject, status } = await Audio.Recording.createAsync(\n   *     Audio.RecordingOptionsPresets.HIGH_QUALITY\n   *   );\n   *   // You are now recording!\n   * } catch (error) {\n   *   // An error occurred!\n   * }\n   * ```\n   *\n   * @return A `Promise` that is rejected if creation failed, or fulfilled with the following dictionary if creation succeeded.\n   */\n  static createAsync = async (\n    options: RecordingOptions = RecordingOptionsPresets.LOW_QUALITY,\n    onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null,\n    progressUpdateIntervalMillis: number | null = null\n  ): Promise<RecordingObject> => {\n    const recording: Recording = new Recording();\n    if (progressUpdateIntervalMillis) {\n      recording._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    }\n    recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n    await recording.prepareToRecordAsync({\n      ...options,\n      keepAudioActiveHint: true,\n    });\n    try {\n      const status = await recording.startAsync();\n      return { recording, status };\n    } catch (err) {\n      recording.stopAndUnloadAsync();\n      throw err;\n    }\n  };\n\n  // Get status API\n\n  /**\n   * Gets the `status` of the `Recording`.\n   * @return A `Promise` that is resolved with the `RecordingStatus` object.\n   */\n  getStatusAsync = async (): Promise<RecordingStatus> => {\n    // Automatically calls onRecordingStatusUpdate.\n    if (this._canRecord) {\n      return this._performOperationAndHandleStatusAsync(() => ExponentAV.getAudioRecordingStatus());\n    }\n    const status = {\n      canRecord: false,\n      isRecording: false,\n      isDoneRecording: this._isDoneRecording,\n      durationMillis: this._finalDurationMillis,\n    };\n    this._callOnRecordingStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  /**\n   * Sets a function to be called regularly with the `RecordingStatus` of the `Recording`.\n   *\n   * `onRecordingStatusUpdate` will be called when another call to the API for this recording completes (such as `prepareToRecordAsync()`,\n   * `startAsync()`, `getStatusAsync()`, or `stopAndUnloadAsync()`), and will also be called at regular intervals while the recording can record.\n   * Call `setProgressUpdateInterval()` to modify the interval with which `onRecordingStatusUpdate` is called while the recording can record.\n   *\n   * @param onRecordingStatusUpdate A function taking a single parameter `RecordingStatus`.\n   */\n  setOnRecordingStatusUpdate(onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null) {\n    this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n    if (onRecordingStatusUpdate == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n    this.getStatusAsync();\n  }\n\n  /**\n   * Sets the interval with which `onRecordingStatusUpdate` is called while the recording can record.\n   * See `setOnRecordingStatusUpdate` for details. This value defaults to 500 milliseconds.\n   * @param progressUpdateIntervalMillis The new interval between calls of `onRecordingStatusUpdate`.\n   */\n  setProgressUpdateInterval(progressUpdateIntervalMillis: number) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  }\n\n  // Record API\n\n  /**\n   * Loads the recorder into memory and prepares it for recording. This must be called before calling `startAsync()`.\n   * This method can only be called if the `Recording` instance has never yet been prepared.\n   *\n   * @param options `RecordingOptions` for the recording, including sample rate, bitrate, channels, format, encoder, and extension.\n   * If no options are passed to `prepareToRecordAsync()`, the recorder will be created with options `Audio.RecordingOptionsPresets.LOW_QUALITY`.\n   *\n   * @return A `Promise` that is fulfilled when the recorder is loaded and prepared, or rejects if this failed. If another `Recording` exists\n   * in your experience that is currently prepared to record, the `Promise` will reject. If the `RecordingOptions` provided are invalid,\n   * the `Promise` will also reject. The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async prepareToRecordAsync(\n    options: RecordingOptions = RecordingOptionsPresets.LOW_QUALITY\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n\n    if (_recorderExists) {\n      throw new Error('Only one Recording object can be prepared at a given time.');\n    }\n\n    if (this._isDoneRecording) {\n      throw new Error('This Recording object is done recording; you must make a new one.');\n    }\n\n    if (!options || !options.android || !options.ios) {\n      throw new Error(\n        'You must provide recording options for android and ios in order to prepare to record.'\n      );\n    }\n\n    const extensionRegex = /^\\.\\w+$/;\n    if (\n      !options.android.extension ||\n      !options.ios.extension ||\n      !extensionRegex.test(options.android.extension) ||\n      !extensionRegex.test(options.ios.extension)\n    ) {\n      throw new Error(`Your file extensions must match ${extensionRegex.toString()}.`);\n    }\n\n    if (!this._canRecord) {\n      if (eventEmitter) {\n        this._subscription = eventEmitter.addListener(\n          'Expo.Recording.recorderUnloaded',\n          this._cleanupForUnloadedRecorder\n        );\n      }\n\n      const {\n        uri,\n        status,\n      }: {\n        uri: string | null;\n        // status is of type RecordingStatus, but without the canRecord field populated\n        status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n      } = await ExponentAV.prepareAudioRecorder(options);\n      _recorderExists = true;\n      this._uri = uri;\n      this._options = options;\n      this._canRecord = true;\n\n      const currentStatus = { ...status, canRecord: true };\n      this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n      this._enablePollingIfNecessaryAndPossible();\n      return currentStatus;\n    } else {\n      throw new Error('This Recording object is already prepared to record.');\n    }\n  }\n\n  /**\n   * Returns a list of available recording inputs. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with an array of `RecordingInput` objects.\n   */\n  async getAvailableInputs(): Promise<RecordingInput[]> {\n    return ExponentAV.getAvailableInputs();\n  }\n\n  /**\n   * Returns the currently-selected recording input. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with a `RecordingInput` object.\n   */\n  async getCurrentInput(): Promise<RecordingInput> {\n    return ExponentAV.getCurrentInput();\n  }\n\n  /**\n   * Sets the current recording input.\n   * @param inputUid The uid of a `RecordingInput`.\n   * @return A `Promise` that is resolved if successful or rejected if not.\n   */\n  async setInput(inputUid: string): Promise<void> {\n    return ExponentAV.setInput(inputUid);\n  }\n\n  /**\n   * Begins recording. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled when recording has begun, or rejects if recording could not be started.\n   * The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async startAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.startAudioRecording());\n  }\n\n  /**\n   * Pauses recording. This method can only be called if the `Recording` has been prepared.\n   *\n   * > This is only available on Android API version 24 and later.\n   *\n   * @return A `Promise` that is fulfilled when recording has paused, or rejects if recording could not be paused.\n   * If the Android API version is less than 24, the `Promise` will reject. The promise is resolved with the\n   * `RecordingStatus` of the recording.\n   */\n  async pauseAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.pauseAudioRecording());\n  }\n\n  /**\n   * Stops the recording and deallocates the recorder from memory. This reverts the `Recording` instance\n   * to an unprepared state, and another `Recording` instance must be created in order to record again.\n   * This method can only be called if the `Recording` has been prepared.\n   *\n   * > On Android this method may fail with `E_AUDIO_NODATA` when called too soon after `startAsync` and\n   * > no audio data has been recorded yet. In that case the recorded file will be invalid and should be discarded.\n   *\n   * @return A `Promise` that is fulfilled when recording has stopped, or rejects if recording could not be stopped.\n   * The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async stopAndUnloadAsync(): Promise<RecordingStatus> {\n    if (!this._canRecord) {\n      if (this._isDoneRecording) {\n        throw new Error('Cannot unload a Recording that has already been unloaded.');\n      } else {\n        throw new Error('Cannot unload a Recording that has not been prepared.');\n      }\n    }\n    // We perform a separate native API call so that the state of the Recording can be updated with\n    // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n    let stopResult: RecordingStatus | undefined;\n    let stopError: Error | undefined;\n    try {\n      stopResult = await ExponentAV.stopAudioRecording();\n    } catch (err) {\n      stopError = err;\n    }\n\n    // Web has to return the URI at the end of recording, so needs a little destructuring\n    if (Platform.OS === 'web' && stopResult?.uri !== undefined) {\n      this._uri = stopResult.uri;\n    }\n\n    // Clean-up and return status\n    await ExponentAV.unloadAudioRecorder();\n    const status = await this._cleanupForUnloadedRecorder(stopResult);\n    return stopError ? Promise.reject(stopError) : status;\n  }\n\n  // Read API\n\n  /**\n   * Gets the local URI of the `Recording`. Note that this will only succeed once the `Recording` is prepared\n   * to record. On web, this will not return the URI until the recording is finished.\n   * @return A `string` with the local URI of the `Recording`, or `null` if the `Recording` is not prepared\n   * to record (or, on Web, if the recording has not finished).\n   */\n  getURI(): string | null {\n    return this._uri;\n  }\n\n  /**\n   * @deprecated Use `createNewLoadedSoundAsync()` instead.\n   */\n  async createNewLoadedSound(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<SoundObject> {\n    console.warn(\n      `createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name`\n    );\n    return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n  }\n\n  /**\n   * Creates and loads a new `Sound` object to play back the `Recording`. Note that this will only succeed once the `Recording`\n   * is done recording and `stopAndUnloadAsync()` has been called.\n   *\n   * @param initialStatus The initial intended `PlaybackStatusToSet` of the sound, whose values will override the default initial playback status.\n   * This value defaults to `{}` if no parameter is passed. See the [AV documentation](/versions/latest/sdk/av) for details on `PlaybackStatusToSet`\n   * and the default initial playback status.\n   * @param onPlaybackStatusUpdate A function taking a single parameter `PlaybackStatus`. This value defaults to `null` if no parameter is passed.\n   * See the [AV documentation](/versions/latest/sdk/av) for details on the functionality provided by `onPlaybackStatusUpdate`\n   *\n   * @return A `Promise` that is rejected if creation failed, or fulfilled with the `SoundObject`.\n   */\n  async createNewLoadedSoundAsync(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<SoundObject> {\n    if (this._uri == null || !this._isDoneRecording) {\n      throw new Error('Cannot create sound when the Recording has not finished!');\n    }\n    return Sound.createAsync(\n      // $FlowFixMe: Flow can't distinguish between this literal and Asset\n      { uri: this._uri },\n      initialStatus,\n      onPlaybackStatusUpdate,\n      false\n    );\n  }\n}\n\nexport { PermissionResponse, PermissionStatus, PermissionHookOptions };\n\nexport * from './RecordingConstants';\n\nexport * from './Recording.types';\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}